# 🎬 Example-001: VRMアニメーション再生

> **難易度:** ⭐⭐☆☆☆（初級〜中級）  
> **学習時間:** 約30分  
> **前提知識:** HTML/CSSの基本、JavaScriptの変数・関数

---

## 📖 このサンプルについて

このサンプルでは、**VRMモデルを読み込んでアニメーションを再生する**方法を学びます。
VRM 1.0の最新仕様に対応したモダンな実装になっています。

### 学べること
- ✅ Three.jsの基本（シーン、カメラ、レンダラー）
- ✅ VRM 1.0のプラグイン方式での読み込み
- ✅ VRMAファイル（アニメーション）の再生
- ✅ リターゲティングの仕組み

---

## 🚀 動かしてみよう！

### 手順

1. VS Codeでこのフォルダを開く
2. `index.html` を右クリック → **「Open with Live Server」**
3. ブラウザでキャラクターが踊り出したら成功！🎉

> ⚠️ **うまくいかない場合は？**  
> ページ下部の「トラブルシューティング」を確認してください。

---

## 📁 ファイル構成

```
example-001/
├── index.html      # メインのHTMLファイル
├── main.js         # JavaScriptのロジック
├── vrm/
│   └── model.vrm   # 3Dキャラクターモデル
└── vrma/
    ├── VRMA_01.vrma  # アニメーションファイル1
    ├── VRMA_02.vrma  # アニメーションファイル2
    └── ...           # （複数のアニメーション）
```

---

## 🎓 コード解説：5つのステップで理解しよう

JSとThree.js、そしてVRMの世界へようこそ！
提示されたコードは、**「最新のVRM 1.0仕様」**に対応したモダンな実装であり、単にモデルを表示するだけでなく、標準規格である`.vrma`（VRM Animation）形式のアニメーションを再生する高度な機能まで含まれています。

---

### Step 1: 基礎環境と「おまじない」の理解 🏗️

まずはThree.jsの基本設定です。ここはVRMに限らず、3D表現の共通基盤です。

#### 🎨 色空間（Color Space）の罠

コード内の以下の部分に注目してください。

```javascript
renderer.outputColorSpace = THREE.SRGBColorSpace; 
```

**なぜこれが必要？**
Three.js r152以降およびVRM 1.0のガイドラインでは、「リニアワークフロー」が推奨されています。これを設定しないと、モデルが**暗くくすんで表示**されてしまいます。

> 💡 **学習ポイント:**  
> 「色が変だな？」と思ったら、まずはこの `outputColorSpace` の設定を疑いましょう。

---

### Step 2: ローダープラグインシステム（最重要）🔌

ここが `three-vrm` **v1.0 の最大の変更点**であり、学習の核心です。

#### コードの解説

```javascript
// VRMローダー
loader.register((parser) => {
  return new VRMLoaderPlugin(parser);
});

// VRMアニメーションローダー
loader.register((parser) => {
  return new VRMAnimationLoaderPlugin(parser);
});
```

#### 🧠 ここで学ぶべき概念

以前のバージョン（v0.x）では `VRM.from(...)` のような独自の読み込み方をしていました。しかし、v1.0からは **「GLTFLoader のプラグイン（拡張機能）として VRM を扱う」** という設計に変わりました。

```
┌─────────────────────────────────────────┐
│ GLTFLoader（標準の3Dモデル読み込み機）    │
├─────────────────────────────────────────┤
│  🔌 VRMLoaderPlugin                     │
│     「VRMデータがあったら処理してね」     │
│                                         │
│  🔌 VRMAnimationLoaderPlugin            │
│     「VRMAデータがあったら処理してね」    │
└─────────────────────────────────────────┘
```

> 💡 **学習のコツ:**  
> 「VRMも結局はGLTF（3Dモデルの標準規格）の一種なんだ」と理解することが重要です。この仕組みのおかげで、Three.jsの標準機能との親和性が高まりました。

---

### Step 3: モデルのロードと初期化 📦

モデルを読み込んだ後の処理です。

```javascript
loader.load(..., (gltf) => {
    const vrm = gltf.userData.vrm; // ここにVRMデータが入っている
    
    // ...中略...

    VRMUtils.removeUnnecessaryJoints(gltf.scene); // 最適化
    scene.add(vrm.scene);
    
    // ...中略...
});
```

#### 🔍 注目ポイント: `userData`

GLTFLoaderで読み込むため、VRMデータは `gltf` オブジェクトそのものではなく、 `gltf.userData.vrm` という「引き出し」の中に入っています。

#### 🛠 v1.0 マイグレーションの注意点（Tips）

もし読み込んだモデルが「後ろ（Z-方向）」を向いてしまっている場合、それは古い規格（VRM0.0）で作られたモデルかもしれません。その場合、以下のコードを追加して補正します。

```javascript
VRMUtils.rotateVRM0(vrm); // VRM0.0の場合、向きを180度回転して合わせる
```

> 📖 **Migration Guide より:**  
> VRM1.0では正面方向がZ-からZ+に変更されました。`rotateVRM0`はVRM0.0モデルのみに作用し、VRM1.0モデルには何もしません。

---

### Step 4: アニメーションの魔法（Retargeting）✨

このコードのハイライト部分です。単にアニメーションを再生するのではなく、**「リターゲティング」**を行っています。

```javascript
// VRM専用のAnimation Clipを作成
const clip = createVRMAnimationClip(vrmAnimations[0], vrm);
```

#### 🧠 なぜリターゲティングが必要？

3Dモデルは、身長や腕の長さがそれぞれ違います。アニメーションデータをそのまま流し込むと、腕が体にめり込んだり、足が浮いたりします。

```
┌────────────────────────────────────────────────────────┐
│ リターゲティングなし ❌                                 │
├────────────────────────────────────────────────────────┤
│                                                        │
│  アニメーション     モデルA      モデルB                │
│  （身長170cm用）  （身長170cm）（身長150cm）           │
│       ↓              ✅           ❌                  │
│                    ぴったり！    腕がめり込む...        │
│                                                        │
└────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────┐
│ リターゲティングあり ✅                                 │
├────────────────────────────────────────────────────────┤
│                                                        │
│  createVRMAnimationClip(アニメ, モデル)                │
│       ↓                                                │
│  「このモデルの体格に合わせて自動調整！」               │
│       ↓                                                │
│  どんなモデルでも自然に動く 🎉                         │
│                                                        │
└────────────────────────────────────────────────────────┘
```

> 💡 **学習ステップ:**
> 1. まずは `THREE.AnimationMixer` の仕組み（Action, Clip）を公式ドキュメントで学ぶ
> 2. 次に、VRM特有の `createVRMAnimationClip` がその橋渡しをしていることを理解する

---

### Step 5: 命を吹き込むループ（Update Loop）🔄

```javascript
function animate() {
  const deltaTime = clock.getDelta(); // 前のフレームからの経過時間

  // 1. 揺れもの（髪、スカート）の計算
  if (window.currentVrm) {
    window.currentVrm.update(deltaTime);
  }

  // 2. ポーズ（アニメーション）の進行
  if (currentMixer) {
    currentMixer.update(deltaTime);
  }
  // ...
}
```

#### ⏱ デルタタイム（deltaTime）とは？

`update(deltaTime)` を呼ぶことで、PCの性能に関わらず一定の速度で「髪を揺らす」「アニメーションを進める」処理が行われます。

```
┌────────────────────────────────────────┐
│ deltaTimeがない場合 ❌                  │
├────────────────────────────────────────┤
│                                        │
│  高性能PC → 120fps → アニメ超高速！    │
│  低性能PC → 30fps → アニメ超スロー...  │
│                                        │
│  同じアニメなのに速度がバラバラ 😵      │
│                                        │
└────────────────────────────────────────┘

┌────────────────────────────────────────┐
│ deltaTimeがある場合 ✅                  │
├────────────────────────────────────────┤
│                                        │
│  高性能PC → 少しずつ進める             │
│  低性能PC → 大きく進める               │
│                                        │
│  どの環境でも同じ速度！ 🎉             │
│                                        │
└────────────────────────────────────────┘
```

---

## 🛠️ トラブルシューティング

### よくあるエラーと解決方法

| エラー | 原因 | 解決方法 |
|-------|------|---------|
| 画面が真っ白 | CORSエラー | Live Serverを使う |
| `404 Not Found` | ファイルパス間違い | `vrm/`や`vrma/`のパスを確認 |
| モデルが暗い | 色空間設定ミス | `outputColorSpace`を確認 |
| モデルが後ろ向き | VRM0.0モデル | `VRMUtils.rotateVRM0()`を追加 |
| 髪が動かない | updateが呼ばれていない | `vrm.update(deltaTime)`を確認 |

> 💡 **デバッグのコツ:**  
> ブラウザの**デベロッパーツール**（F12キー）の「Console」タブを見てください。赤いエラーメッセージがヒントになります。

---

## 🎓 おすすめの学習ロードマップ

### Level 1: コードをいじって「壊して」直す 🔧

まずはこのコードを手元で動かしてみましょう。

1. **モデルを変える:** 自分の好きな `.vrm` ファイルに差し替えてみる
2. **ライトを変える:** `DirectionalLight` の位置や色を変えて、雰囲気がどう変わるか見る
3. **カメラ位置を変える:** `camera.position` の数値を変えてみる

### Level 2: 表情（Expression）を制御する 😊

VRM 1.0の大きな特徴は表情制御です。コンソール（ブラウザのF12）で以下を実行してみましょう。

```javascript
// 喜びの表情をセット (1.0 = 100%)
window.currentVrm.expressionManager.setValue('happy', 1.0);
window.currentVrm.update(0.1); // 更新を反映
```

> 📖 **Migration Guide より:**  
> 以前は `blendShapeProxy` と呼ばれていましたが、v1.0からは `expressionManager` に名称変更されました。

### Level 3: インタラクションを追加する 🖱️

「クリックしたら表情が変わる」「キーボードでアニメーションを切り替える」といった機能を追加してみましょう。

- JavaScriptの `addEventListener` を学びます
- 複数の `.vrma` ファイルを読み込んで切り替えるロジックを考えます

### Level 4: ドキュメントを読む癖をつける 📚

実装に詰まったら、ChatGPTに聞く前に一度ドキュメントを検索してみましょう。

- **Three.js:** https://threejs.org/docs/
- **three-vrm:** https://pixiv.github.io/three-vrm/packages/three-vrm/docs/

---

## 📖 関連ドキュメント

- [01.GLTF.md](../docs/01.GLTF.md) - glTFの基礎知識
- [02.VRMUtils最適化.md](../docs/02.VRMUtils最適化.md) - パフォーマンス改善
- [03.async-await.md](../docs/03.async-await.md) - 非同期処理の理解
- [example-002](../example-002/README.MD) - GUI操作編（次のステップ）

---

## 🎉 まとめ

このコードは、**「VRMを表示し、標準的なアニメーションを再生する」というゴールのための黄金パターン**と言えます。

まずは環境構築（ViteやWebpack、または簡単なHTML）を行い、このコードをコピペして `model.vrm` と `motion.vrma` を用意し、画面にキャラクターが表示される感動を味わってください！