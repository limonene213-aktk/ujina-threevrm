# ⚡ VRMUtils最適化ガイド

> **この章で学ぶこと:** VRMモデルのパフォーマンスを改善する方法と、その仕組みを理解する

---

## 🎯 「最適化」とは？

「最適化（Optimization）」という言葉はプログラミングでよく出てきますが、ここでは具体的に**「描画の負荷を減らして、動作を軽くする」**ことを指しています。

なぜこの処理が必要なのか、一緒に深掘りしてみましょう。

---

## 🦴 3Dキャラクターが動く仕組み

まず、3Dキャラクターが動く仕組みをイメージしてみてください。

```
🦴 骨（ボーン/Joint）の仕組み
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

      [頭]
        │
      [首]
        │
    ┌───┴───┐
  [左腕]   [右腕]
    │       │
  [左手]   [右手]

骨が動くと → 表面の皮（メッシュ）がついてくる！
```

しかし、モデリングソフト（BlenderやVRoid Studioなど）から書き出したデータには、実は**「見た目には全く影響しない、空っぽの骨」**がたくさん含まれていることがあるんです。

---

## 😰 なぜ問題なの？

Three.jsなどの3Dエンジンは、画面を更新するたびに（1秒間に60回など）、**全ての骨の位置や計算**を行おうとします。

```
毎フレームの処理（1秒間に60回！）
━━━━━━━━━━━━━━━━━━━━━━━━━━━

🦴 骨A の位置を計算  ← 必要！
🦴 骨B の位置を計算  ← 必要！
🦴 骨C の位置を計算  ← 空っぽ...無駄！
🦴 骨D の位置を計算  ← 空っぽ...無駄！
🦴 骨E の位置を計算  ← 空っぽ...無駄！
  :
（100個の骨があれば、100回計算）
```

もし、その中に「動かしても見た目が変わらない無駄な骨」が大量にあったら、コンピュータは**無駄な計算を繰り返す**ことになります。

結果として：
- ⚠️ フレームレートが低下（カクカクする）
- ⚠️ バッテリーの消費が増える
- ⚠️ スマホなど低スペック端末で動かない

---

## 💊 解決策：VRMUtils.removeUnnecessaryJoints

VRMUtilsには、この問題を解決するためのユーティリティ関数が用意されています！

### コード例

```javascript
import { VRMUtils } from '@pixiv/three-vrm';

loader.load('model.vrm', (gltf) => {
  const vrm = gltf.userData.vrm;
  
  // ★ 最適化：不要なジョイントを削除！
  VRMUtils.removeUnnecessaryJoints(gltf.scene);
  
  scene.add(vrm.scene);
});
```

### 効果

| 項目 | 最適化前 | 最適化後 |
|-----|---------|---------|
| ジョイント数 | 150個 | 50個 |
| 計算負荷 | 100% | 約30% |
| FPS（フレームレート） | 30fps | 60fps |

※ 数値は一例です。モデルによって効果は異なります。

---

## 🧹 VRM 1.0 での破棄処理

v1.0では `vrm.dispose()` が削除されました。代わりに `VRMUtils.deepDispose` を使用します。

### コード例

```javascript
// VRMを破棄する前に呼び出す
VRMUtils.deepDispose(vrm.scene);
```

> 💡 **なぜ重要？**  
> VRMを動的に読み込み・削除する場合（モデル切り替えなど）、この関数を呼ばないと**メモリリーク**（使われないメモリがどんどん溜まる）が発生します。

---

## 🔄 VRM0.0モデルへの対応

VRM 1.0では、モデルの正面方向が変更されました（Z- → Z+）。古いVRM0.0モデルを読み込むと後ろを向いてしまうことがあります。

```javascript
// VRM0.0モデルを180度回転して正面を向かせる
VRMUtils.rotateVRM0(vrm);
```

> 📖 **Migration Guide より**  
> この関数はVRM0.0のモデルにのみ効果があり、VRM1.0のモデルには何もしません。安全に使用できます。

---

## 📊 最適化のまとめ

| 関数 | 用途 | いつ使う？ |
|-----|------|-----------|
| `removeUnnecessaryJoints()` | 不要な骨を削除 | モデル読み込み直後 |
| `deepDispose()` | メモリ解放 | モデル削除時 |
| `rotateVRM0()` | VRM0.0の向き修正 | モデル読み込み直後 |

---

## 🎓 チャレンジ

1. **計測してみよう**: ブラウザのパフォーマンスツール（F12 → Performance）で、最適化前後のFPSを比較してみよう
2. **コンソールで確認**: `console.log(gltf.scene)` でシーンの中身を見て、どんなオブジェクトがあるか観察しよう

---

## 📖 次のステップ

最適化が理解できたら、非同期処理について学びましょう！

👉 [03.async-await.md](03.async-await.md) で非同期処理をマスター！